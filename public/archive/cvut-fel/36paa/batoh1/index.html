<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
   <meta http-equiv="content-type" content="text/html; charset=windows-1250">
   <meta name="generator" content="PSPad editor, www.pspad.com">
   <link rel="stylesheet" type="text/css" href="../style.css">
   <title>36PAA - ulohy (Michal Trs)</title>
</head>
<body>
   <h1>36PAA - Batoh 1</h1>

   <div id="main">
      <h2>Zad�n�</h2>
      <ul>
         <li>Naprogramujte �e�en� 0/1 probl�mu batohu hrubou silou. Na zku�ebn�ch datech pozorujte z�vislost v�po�etn�ho �asu na n.</li>
         <li>Naprogramujte �e�en� 0/1 probl�mu batohu heuristikou podle pom�ru cena/v�ha. Pozorujte
         <ul>
            <li>z�vislost v�po�etn�ho �asu na n. Grafy jsou v�t�ny (i pro exaktn� metodu).</li>
            <li>pr�m�rn� zhor�en� proti exaktn� metod�</li>
            <li>maxim�ln� relativn� chybu. Absolutn� chyba nic ne��k�!</li>
         </ul></li>
      </ul>

      <h2>Definice probl�mu</h2>
      <ul>
         <li>Je d�no:
         <ul>
            <li>cel� ��slo n (po�et v�c�)</li>
            <li>cel� ��slo M (kapacita batohu)</li>
            <li>kone�n� mno�ina V={v1, v2, ... ,vn } (hmotnosti v�c�)</li>
            <li>kone�n� mno�ina C={c1, c2, ... ,cn } (ceny v�c�)</li>
         </ul></li>

         <li>Zkonstruujte mno�inu X={x1, x2, ... ,xn }, kde ka�d� xi je 0 nebo 1, tak, aby
         <ul>
            <li><b>platilo:</b> v1x1+v2x2 + ... + vnxn <= M (batoh nebyl p�et�en).</li>
            <li><b>v�raz</b> c1x1+c2x2 + ... + cnxn nab�val maxim�ln� hodnoty pro v�echny takov� mno�iny (cena v�c� v batohu byla maxim�ln�).</li>
         </ul></li>
      </ul>

      <h2>Implementace</h2>
      �lohu jsem implementoval v Jazyce C# jako konzolovou aplikaci. Data na��t� ze standardn�ho vstup a v�sledky vypisuje na stdandardn� v�stup. �e�en� jsem rozd�lil do 4 t��d.
      <ul>
         <li><a href="source/Batoh.cs">Batoh.cs</a> - Virtu�ln� t��da, m� implementovan� metody pro na��t�n� ze standardn�ho vstupu, v�pis na standardn� v�stup a virtu�ln� metodu Compute().</li>
         <li><a href="source/BruteForce.cs">BruteForce.cs</a> - �e�en� hrubou silou, implementov�no rekurzivn�.</li>
         <li><a href="source/GreedyProof.cs">GreedyProof.cs</a> - Jednoduch� heuristika, nejprve vypo�te pom�r cena/v�ha a nastav� pomocn� pole s indexy, kter� p�edstavuj� po�ad� ve kter�m budou prvky do batohu p�id�v�ny (od nejlep��ho pom�ru).</li>
         <li><a href="source/Program.cs">Program.cs</a> - Na�te vstupn� data a vol� metodu Compute() a m��� �as.</li>
      </ul>

      <h3>Parametry programu</h3>
      <ul>
         <li><b>-g</b> jednoduch� heuristika (GreedyProof), jinak hrub� s�la (BruteForce).</li>
         <li><b>-t:<i>count</i></b> Pro m��en� �asu, ka�dou instanci opakuje <i>count</i>-kr�t.</li>
      </ul>


      <h2>Nam��en� hodnoty a v�sledky</h2>
      <p>M��il jsem na NTB s procesorem Centino 1.4GHz, nastaven� max Performance p�i nap�jen� z adapt�ru. Pou�it� OS: Windows XP SP2 s .net Framework 2.</p>

      <h3>Tabulka v�sledk� m��en�</h3>
      <p>Proto�e rozli�en� ��ta�e (Environment.TickCount) je 16 ms, je nutn� instance spo��tat v�cekr�t a v�sledn� �as z�skat vyd�len�m po�tem opakov�n�. Pro m��en� �asov� slo�itosti hrub� s�ly jsem experiment�ln� nastavoval po�et opakovan� od 100 000 (pro n = 4) do 1 (pro n = 30). Pro m��en� heuristiky jsem nastavil 100 000 opakov�n� pro ka�dou instanci probl�mu.</p>
      <table>
         <tr><th>n</th><th>hrub� s�la [ms]</th><th>heuristika [ms]</th><th>ID<sub>max. chyby</sub></th><th>prum. zhor�en�</th><th>max. chyba</th></tr>
         <tr><td>4</td><td>0,0075</td><td>0,0071</td><td>9037</td><td>2,17%</td><td>36,36%</td></tr>
         <tr><td>10</td><td>0,044</td><td>0,015</td><td>9080</td><td>1,73%</td><td>11,48%</td></tr>
         <tr><td>15</td><td>1,229</td><td>0,021</td><td>9126</td><td>1,32%</td><td>8,54%</td></tr>
         <tr><td>20</td><td>36,865</td><td>0,027</td><td>9165</td><td>1,14%</td><td>8,43%</td></tr>
         <tr><td>22</td><td>136,736</td><td>0,030</td><td>9237</td><td>1,05%</td><td>7,23%</td></tr>
         <tr><td>25</td><td>1140,04</td><td>0,034</td><td>9283</td><td>0,96%</td><td>3,68%</td></tr>
         <tr><td>27</td><td>4803,9</td><td>0,036</td><td>9338</td><td>0,90%</td><td>10,60%</td></tr>
         <tr><td>30</td><td>38723,1</td><td>0,041</td><td>9380</td><td>0,85%</td><td>5,51%</td></tr>
      </table>

      <h3>Graf: �asov� z�vislost</h3>
      <p><img src="grafy/slozitost.png" alt="�asov� slo�itost"/></p>
      
      <h3>Graf: Z�vislost pr�m�rn� chyby na velikosti instance</h3>
      <p><img src="grafy/pr_chyba.png" alt="Z�vislost pr�m�rn� chyby na velikosti instance"/></p>
      
      <h3>Graf: Z�vislost maxim�ln� chyby na velikosti instance</h3>
      <p><img src="grafy/max_chyba.png" alt="Z�vislost maxim�ln� chyby na velikosti instance"/></p>


      <h2>Z�v�r</h2>
      <p>
         �e�en� hrubou silou d�v� sice nejlep�� mo�n� �e�en�, ale dan� za prohled�n� cel�ho stavov�ho prostoru je ne�nosn� (exponenci�ln�) �asov� slo�itost. P�ekvapuj�c� jsou pom�rn� dobr� v�sledky jednoduch� heuristiky. �asov� z�vislost je line�rn� (obsahuje velkou multiplikativn� konstantu, tak�e pro mal� n se neprojev� slo�itost �azen� n.log(n)) a dosahuje pr�m�rn� chyby v nejhor��m p��pad� 2,17% pro zadan� instance. Z grafu je dob�e patrn�, �e pr�m�rn� relativn� chyba s velikost� instance kles�.
      </p>

   </div>

<script src="/archive/lightbox.js"></script>
</body>
</html>
